This is not in any way an emulator, it is a piece of interactive software that helps you to understand what is going on with 6502 assembly code. You enter the 6502 assembly code in the text area and then you can step through the code and see the fetch/decode/execute cycle, see how the memory addressing works and monitor the registers and memomry contents.

Abstracted pseudo-assembly code notation:

Memory Accesses are represented like access to an array M.

sometimes a byte is fetched, sometimes a word is fetched, if a word is fetched it is written Mw

lets start understanding some basic 6502 samples.

The internal representation of information:
All information in a computer is stored as groups of bits. A bit stands for a binary digit (0 or 1). Because of the limitations of conventional electronics, the only practical representation of information uses two-state logic. The two states of the circuit used in digital electronics are generally 'off' and 'on' and these are represented logically by the symbols "0" and "1". Because these circuits are used to implement "logical" functions they are called "binary logic".

In the case of microprocessors in general, and of the 6502 in particular, these bits are structured in groups of 8. A group of 8 bits is called a byte.

Signed Binary
In a signed binary representation, the left most bit is used to indicate the sign of the number. Traditionally "0" is used to denote a positive number whilte "1" is used to donate a negative number. Now "11111111" is -127 while "01111111" is +127. We can now represent positive and negative numbers but we have reduced the maximum magnitude of these numbers to 127.

_Hardware Organisation_
In order to program at an elementary level, it is not necessary to understand in detail the internal structure of the processor that one is using. However, in order to do efficient programming such an understanding is requireed. The purpose of this chapter is to present the basic hardware concepts necessary to unedrstanding the operation of the 6502 system. The complete microcomputer system includes not only the microprocessor unit (here the 6502) but also other components.

We will review the basic architecture of the microcomputer system, then study more closely the internal organisation of the 6502. We will examine in particular, the various registers. We will then study the program execution and sequencing mechanism. From a hardware standpoint, this chapter is only a simplified presentation.

The architecture of the microcomputer system appears in Fig 2.1 The microprocesssor unit (MPU) which will be a 6502 here appears on the left of the illusttrarion. It implements the functions of a central processing unitt (CPU) within one chip. It includes an arithmetic-logical-unit, plus its internal registeres and a control unit (CU) in charge of sequencing the system. Its operation will be explained in this chapter.

The MPU creates three buses: an 8-bit bi-directional data-bus which appears at the top of the illustration, a 16-bit mono-directional address-bus and a control-bus which appears at the bottom of the illustration.

Let us describe the function of each of the buses.

The data-bus carries data being exchanged by the various elements of the system. Typically, it will carry data from the memory to the MPU, from the MPU to the memory, or from the MPU to an i/o chip.

The address-bus carries an address generated by the MPU, which will select one internal register within one of the chips attached to the system. This address specifies the source, or the destination, of thhe data which will transit along the data bus.

The control-bus carries the various synchronization requireed by the system.

Having described the purpose of the buses, let us now connect the aditional component required by a complete system.

Every MPU requires a precise timing reference, which is supplied by a clock and a crystal. In most 'older' microprocessors, the clock-oscillator is extarnal to the MPU and requires and extra chip. In most recent microprocessors, the clock oscillator is usually incorporated within the MPU.

The quartz crystal, however, because of its bulk is always external to the system. The crystal and the clock appear on the left of the MPU box in the illustration.

Let us now turn our attention to the other elements of the system. Going from left to right on the illustration, we distinguish:

The ROM is the read-only-memory and contains the program for the system. The advantage of ROM is that its contents are permanent and do not disappear whenever the system is turned off.

The ROM therefore, always contains a bootstrap or a monitor program (their function will be explained later) to permit initial system operation. In a process-control environment, nearly all the program will reside in ROM as they will probably never be changed. In such case, the industrial user has to protext the system against power failures: programs may not be volitile. They must be in ROM.

However, in a hobbyist environment, or in a program development environment, most of the programs will reside in RAM, it is volatile, its contents are lost when power is turned off.

The RAM is the read/write memory for the system. In the case of a control system, the amount of RAM will typically be small. On the other hand, in a program development environment, the amount of RAM will be large, as it will contain programs plus development software. All RAM contents must be loaded prior to use from an external device.

Finally, the system will contain one or more interfae chips so that it may communicate with the outside world. The most frequent used interface chip is the PIO or parallel input output chip. It is the one shown in the illustration, ths PIO like all other chips in the system connects to all 3 busses and provides at least 2 16-but ports for communication with the outside world. For more details on how actual PIO works refer to book C201 or else, for specifics of the 6502 system refer to chapter 7 (I/O devices)

All these chips are connected to all three busses, including the control bus. However, to clarify the illustration the connections between the control bus and these various chips are not shown.

The functional modules which have been described need not necessarily reside on a single LSI chip, in fact, we will use a combination chips which include both a PIO and a limited amount of ROM or RAM

Still more components will be required to build a real system, In particular, the busses usually need to be buffered. Also decoding logic may be used for the memory RAM chips, and finally some signals may need to be amplified by drivers. The auxiliary circuits will not be described here as they are not relevant to programming. The reader interested in specific assembly and interfacing techniques is referred to book C207

Internal Organisation of the 6502.

The arithmetic logic unit (ALU) appears on the right of illustration, it can easily be recognized by its characteristic V shape. The function of the ALU is to perform arithmetic and logical operations on the data which is fed to it vai its two input ports. The two input ports of the ALU are respectively the "left input" and the "right input" They correspond to the top extremities of the V shape. After performing the arithmetic operation such as assition or subtraction, the ALU outputs its contents at the bottom of the illustration.

The ALU is equiped with a special register, the Accumulator (A) the accumulator is on the left input. The ALU will automatially reference this accumulator as on of its inputs (however a bypass also exists) This is classic accumulator based design. In arithmetic and logical operations, one of the operands will be the accumulator, and the other will typically be a memory location. The result will be deposited in the accumulator. Referencing the accumulator as both source and the destination for data is the reason for its name, it accumulated results. The advantage of tis accumulator based approach is the possiility of using very short instructions just a single byte to specify the opcode. if the operand had to be fetched from one of the other registers 9other than an accumulator) it would be necessary to use a number of extra bits to designate this register in the instruction.

By the side of the ALU, to it's left appears a special 8 bit register, the processor status flags (P). The register contains 8 status bits. each of these bits, pysically implemented by a flip-flop inside the register is used to denote a special conditioin. The function of the various status bits will be explained progressively during the programming examples presented in the next chapter, and will be described completely in chapter 4 which presents the complete instruction set. As an example, three such status flags are the N, Z and C bits. N stands for negative. It is bit 7 of register P. Whenever this bit if one it indicates that teh result of the operation through the ALU was negative.
Bit Z stands for zero, whenever this bit (bit position 1) is a one, it denotes that a zero result was obtained. Bit C in the right most position, is a carry bit, whenever two 8 bit numbers are addeed and the result can't be contained in 8 bits, bit C is the 9th bit of the result.

These status bits are set automatically by the various instructions. A complete list of the instructions and the way in which they affect the status bits of the system appears in appendix A as well as in chapter 4. These bits will be used by the programmer to test various special or exceptional conditoins, or else to test quickly for some errornous result. As an example, tersing bit Z may be accomplished with special instructions and will immediately tell whether the result of previous operation was 0 or not. All decisions in an assembly language program ie in all the programs in this book, will be based on the testing of bits. These bits will be either bits that will be read from the outside world, or else the status bits of the ALU. It is therefore very important to understand the functin and use of all status bits in the system. The ALU here is equiped with a status register containing these bits. All other i/o chops in the system will also be equipped with the status bits.

Let us move leftwards of the ALU. The horizontal rectangles represent the internal registers of the 6502. PC is the program counter. It is a 16bit register and is phsyically implemented as two 8 bit registers: PCL and PCH. L is low (bits 0-7) H is high (bits 8 - 16). The program counter is a 16bit register which contains the address of the next instructioon to be executed. Every computer is equipped with a program counter so that it knows which instruction to execute next.

One last area has not yet been explained. It is the set of 3 registers labeled X, Y and S. Registers X and Y are called index registers. They are 8 bits wide. They may be used to contain data on which the program will operate. However they normally are used as index registers. These 2 registers are not completely symetrical and their roles will be differentiates in the chapter on addressing techniques. The stack register is uesd to contain a pointer to the top of the stack area within memory.

S is a dedicated register, it stores the Stack Pointer, ie the address of the top element of the stack, the stack is then implemented as an area of memory. The stack pointer will thereforer require 16 bits to point anywhere in the memory.

In the 6502 the stack pointer is restricted to 8 bits. It includes a 9th bit, in the left-most position, always set to 1. In other words, the area allocated to the stack in the case of the 6502 ranges from address 256 to address 511. In binary, this is 1000 0000 to 1111 1111 - the stack always starts at address 1111 1111 and may have up to 255 'words' This may be viewed as a limitation of the 6502 and will be discussed later in this book. In the 6502 the stack is at the high address, and grows 'down' the stackpointer is 'decremented' by a PUSH. In order to use the stack, the programmer simply initialises the S register, the rest is automatic.

The stack isi said to reside in page 1 of the memmory.

_The Paging Concept_
The 6502 microprocessor is equiped with a 16-bit address-bus. 16 binary bits may be used to create 2^16 = 64k combinations. Because of addressing features of the 6502 which will be presented in chpter 5, it is convenient to partition the memory into logical pages. A page is simply a block of 256 words. Thus memory locations 0 to 255 are page 0 of memory, it will be used for 'zero page' addressing, page 1 of the memory includes location 256 to 511, normally reserved for the stack. All other pages are unconstrained by the design and may be used in any way. In the case of the 6502, it is important to keep in mind the page organisation of the memory. Whenever a page boundary has to be crossed, it will often introduce extra cycle delay in the execution of an instruction.

// Electron User Guide //

Before the routine can be assembled, the computer must be told where it is to be put in memory.

so we must allocate some memory for this purpose, and there are two ways in which you can do this.

you must assign a resident variable p% the value you choose to be the address of the first instruction (p = pseudo program counter)

the two methods for doing this are:

1. p% = &2000 for example // for this you must ensure that the memory location is available
2. use the Basic DIM instruction.

- different instructions take up different amounts of memory
- there are directives,

10 OSASCI=&FFE3
20 DIM MC% 100
30 DIM data &20
40 FOR opt%=0 TO 3 STEP 3
50 P%=MC%
60 [
70 OPT opt%
80 .entry LDX #0 \ set index count (in X reg.) to 0
90 .loop LDA data,X \ load next VDU parameter
100 JSR OSASCI \ perform VDU command
110 INX \ increment index count
120 CPX #&20 \ has count reached 32 (&20) ?
130 BNE loop \ if not then go round again
140 RTS \ back to BASIC
150 ]
160 NEXT opt%
170 !data=&04190416
180 data!4=&00C800C8
190 data!8=&00000119
200 data!&C=&01190064
210 data!&10=&000000C8
7
220 data!&14=&00000119
230 data!&18=&0119FF9C
240 data!&1C=&0000FF38
250 PRINT'"Press key to run program":A=GET
260 CALL entry

The Location Counter p%

When the assembler creates the machine code program, the code produced is placed in memory starting from the address in p%

The programmer must set p% to a meaningful value before the assembly begins.

The usual method for short programs to DIMension a block of memory and to set p% to this value at the beginning of each pass of the assembler.

The assembler updates p% as it is assembling and when it reaches the endow the pass the value of p% represents the address of the first 'free' byte of memory after the machine code program.

2.4 Labels
Any BASIC numerically assignable item may be used as a label with the
assembler (such as a variable or an array element). A label is defined by
preceding the variable name with a full stop. The full stop prefix causes
the assembler to set up a BASIC variable containing the current value of
P%. Once set up this variable is available for use by any other part of the
assembler or BASIC program

. Constructing a Pure Interpreter

Introduction:
In this chapter, we will learn how to extend the p1.py parser from problem 1 in chapter 7 so that it not only parses the source program but also interprets it.

You will be surprised how few modifications are needed to turn your parser into a pure interpreter. Recall that a pure interpreter executes the source program directly - it does not first translate it to another form.

Structures Needed for a Pure Interpreter

One of the structures out interpreter needs is a symbol table. It is a table that holds the name of each variable and its corresponding value. A symbol table is easy to implement in python. We simply use a python dictionary. Our interpreter creates and initialises the dictionary it uses as a symbol table with

Symtab = {}

To assign to the symbol table

Symtab['a'] = 1

to check if a symbol is in the symbol table use the in operator

If 'a' in symtab...

Another structure we need in out interpreter is a stack.

Modifications to Our parsing function:

To extend out parser from problem 1 in chapter 7 so it interprets, we have to modify each parsing function.

Each parsing function has to be modified so that it executes the source code it parses. Let's start with the code for the assignmentstsmt() function.

def assignmentstmt():
left = token.lexeme # save lexeme of current token
advance()
consume(ASSIGNOP)
expr()
symtab[left] = operandstack.pop()

The stmt() function calls assignmentstmt() only if the current token is a name. Thus, on entry into assignmentstmt() the current token is the name on the lft side of the source code asignment statement. Line 2 in the assignmentstmt() function

left = token.lexeme

saves the lexeme on the left side of the source code assignment statement in the local variable LEFT. For example, if the souce code assignment statement is

x = y

then left is assigned 'x'.

assignmentstmt() advances past the variable naae and he '=' tokens, and calls expr(). The effect of expr() is to parse the expression on the right side of the source code assignment statement. but it also (because of the modifications we will make) has the effect of leaving the value of the expression on the top of the stack. Thus, the next atatement in assgimentstmt() executes.

In printstmt() there is a call of expr() with the modifications to expr() we will make this call of expr() pushes the value of the expression onto operandstack. Thus, to execute as well as parse printstmt() simply pops operansstack and displays the value popped.

def printstmt():
advance()
consume(LEFTPAREN)
expr()
print(operandstack.pop())
consume(RIGHTPAREN)

To modify expr() so that it leaves the value of the expression on the top of the stack is easy, Simply pop two values from the stack each time the right-side term of an addition has been parsed, add the two values and push the sum back on the stack.

blah

Constructing Tokenizer for 6502

Introduction
The front-end of an interpreters a tokeniser. Most interpreter books present a formal procedure based on computer science theory for design of a tokeniser, however tokenisers are easy to implement in an ad-hoc manor. Thus, although the design-based-on-theory approach for a toekwnizer is interesting, it is an unnecessary diversion for us.

The tokenizer we used in the preceding two chapters (the advance() function) simply returns the next character in the input string each time it is called. The tokeniser we described in the chapter that we need for our python subset is necessarily more. elaborate. It has to handle tokens that can consist of multiple characters, such as variable names and integer constants.

Tokenizer-Parser-Interface

The input to a tokeniser in an interpreter is the source program. The tokeniser breaks up the source program into a sequence of meaningful units called tokens, and provides these tokens to the parser. There are 2 approaches the tokeniser can take.

1. Tokenise the entire source program and then provide to the parser the complete list of tokens. In other words, the tokeniser finishes its job before the parser starts its job

2. Tokenise the source program on an as needed bases. In this approach the parser initially gets control. Whenever it needs the next token from the source program, it calls the tokeniser which then gets the next token and provides it to the parser.

When the parser detects an error in the token steam it is processing it should generate an informative error message, for example, suppose the following statement is on line 7

x = &23

A good error message should specify the location of the error in the source program.

The actions the parser takes usually depend on the category of the token rather than the specific token itself. For example, suppose the parser has to call a particular function if the current token is a variable name, Thus, to determine if it should perform this action, the parser needs to know only the category of the token. The tokeniser can easily provide the category of a token to the parser along with the token itself and its source program location in one convenient bundle. With this information, the parser never has to examine the token itself to determine its category.

Based on our proceeding discussion, the tokeniser should provide the parser with the following four items of information on each token.

1. The line number
2. The column number
3. Its category
4. The token itself. (I.e string of characters that makes up the token) we call this string the lexeme

Our tokeniser uses an object created from the Token class to hold these 4 items of information for each token. The token class is defined as follows

class Token:
def **init**(self, line, column, category, lexeme):
self.line = line
self.column = column
self.category = category
self.lexeme = lexeme

A token object has 4 variables, line, column,catrgory, lexeme, To access a variable in a Token object the name of the variable should be prefixed with a reference that points to the object's variables. For example, if self points to the variables of a Token object then self.category reference the category variable in that object.

**init**() in the Token class is the initialiser is the initialiser method. It initialises the object when it is created. For example, the following statement creates and initialises a Token object, and assigns to token a pointer a newly created object

token = Token(line, column, column, none, '')

After creating a Token object for our token, our tokeniser then appends the token object to a list of tokens name token list. Thus when the tokeniser finishes processing the source program the entire stream of tokens for the source program is available to the parser in tokenlist.

Source program -> | tokeniser | -> tokenList

To represent the various token categories, our tokeniser uses arbitrary non negative integers. For example, the integer representing the category for names is 3. To improve the readability of our code, we give each category number a name, and use category names rather than numbers in our code. The following statements give a name to each category number

LABEL = 0
OPERATOR = 1
ADDRESS = 2
OPERAND = 3
DIRECTIVE = 4
LEFTPAREN = 5
RIGHTPAREN = 6
COMMA = 7
NEWLINE = 8
ERROR = 9
EOF = end of file = 10

Some of the token categories correspond to multiple tokens. For example, the NAME category is the category for any name that is not a keyword. Other categories represent a single token. For example LEFTPAREN

Source:
.entry LDX #0
.loop LDA data,X
JSR OSASCI
INX
CPX #&20
BNE loop
RTS

Line column category lexeme
1 1 LABEL .entry
1 9 OPERATOR LDX
1 12 OPERAND #0
2 1 LABEL .loop
2 9 OPERATOR .LDA
2 12 OPERAND data
2 16 COMMA ,
2 17 OPERAND x
3 9 OPERATOR JSR
3 12 OPERAND OSASCI
4 9 OPERATOR INX
5 9 OPERAND CPX
5 12 OPERAND #&20
6 9 OPERATOR BNE
6 12 OPERAND loop
7 9 OPERATOR RTS

see http://www.6502.org/tutorials/6502opcodes.html

(arm seembly)
1 @ ap1.s
2 .test @ start of read-only segment
3 .global_start  
4 \_start:
5 ldr r0,x @ load r0 from x
6 mov r7, #1 @ mov 1 into r7
7 svc 0 @ suprevisor call to terminate program
8  
9 x: .word 14 @ the variable x

9: ByteCode

Introduction
as we learned in chapter 1, the Python interpreter is a hybrid interpreter. It does not directly interpret the source program. Instead it first compiles the source program to a form that can easily be interpreted called bytecode. It then interprets the bytecode.

Hybrid interpreters like pure interpreters have a tokenizer and a parser, however unlike a pure interpreter, they also have a code generator that produces the translated version of the source program.

Python's bytecode is designed so it can be interpreted quickly - more quickly than the source code from which is is translated - thus the overhead associated with the compile step generally is more than compensated for by the increase in the speed of interpretation.

The bytecode interpreted in a sense is the machine that execures the bytecode. but it, of courrs it not a real machine, for this reason, the bytecode interpreter withiin the python interpreter is called the Python Virtual Machine (PVM)

What is Python Bytecode
Python bytecode is a sequence of instructions. Each bytecode instruction consists of one or two numbers. The first number in a bytecode instruction is the opcode. The opcode specifies the operation to be performed. The second number, if there is one in the instruction, generally is an index into a table of variables or constants. This, via this index, the second number specifies a variable or constant.

The opcode part of a python bytecode instruction occupies just one byte. Because many of the bytecode instructions consist of just the opcode, the entire instruction is only one byte, hence the name 'bytecode'. The compiler component of the hybrid interpreter we will construct generates bytecode that is essentially the same as the bytecode generated by the Python 3 interpreter.

Structures Produced by the Parser in a Hybrid Interpreter
The front end of the hybrid interpreter we will construct - the compiler component - has a tokeniser and a parser. It also has a code generator that produces the bytecode instructions. The code generator is not a seperate component. Rather its code is embedded in the code for the parser. Thus as the parser executes so does the code generator, the effect of which is to produce bytecode.

The code generator produces 3 tables during the parsing of the tokenised source code:

1. co_code: the table in which the code generator stores the bytecode it generates
2. co_names: the table that holds the names of the global variables in the source code
3. co_consts: the table that holds the values of the constants in the source program

view-source:https://www.masswerk.at/6502/js/6502assembler.js
